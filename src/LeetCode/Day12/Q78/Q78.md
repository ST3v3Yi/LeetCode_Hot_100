#### [Q78. 子集](https://leetcode.cn/problems/subsets/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的

子集（幂集）。



解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。



**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```

 

##### 第一种思路：回溯法

**流程**

1. **初始化**：创建一个空的答案列表 `ans`，和一个空的临时列表 `tmp`。
2. **开始递归**：调用 `backtrack` 函数，传入 `ans`，`tmp` 和 `nums`。
3. 在 `backtrack` 函数中：
   - **添加子集**：首先，将 `tmp`（当前的子集）添加到 `ans` 中。
   - **递归生成子集**：然后，对 `nums` 中的每一个元素，如果它还没有被添加到 `tmp` 中，就将它添加到 `tmp` 中，并递归调用 `backtrack` 函数。在递归调用返回后，再将这个元素从 `tmp` 中移除，以回溯到上一步。
4. 当所有的递归调用都返回后，`ans` 中就包含了 `nums` 的所有子集。

**代码**

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        backtrack(ans, new ArrayList<>(), nums, 0);
        return ans;
    }

    public void backtrack(List<List<Integer>> ans, List<Integer> tmp, int[] nums, int start) {
        ans.add(new ArrayList<>(tmp));
        for (int i = start; i < nums.length; i++) {
            tmp.add(nums[i]);
            backtrack(ans, tmp, nums, i+1);
            tmp.remove(tmp.size() - 1);
        }
    }
}
```

**通过测试：**

`执行用时分布`：`0ms`			`击败100%使用 Java 的用户`

`消耗内存分布`：`41.61MB`	`击败66.94%使用 Java 的用户`

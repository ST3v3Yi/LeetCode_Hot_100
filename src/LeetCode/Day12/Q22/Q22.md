#### [Q22. 括号生成](https://leetcode.cn/problems/generate-parentheses/?envType=study-plan-v2&envId=top-100-liked)

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

 

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```
输入：n = 1
输出：["()"]
```

 

##### 第一种思路：

**流程**

1. **初始化**：创建一个空的`StringBuilder`变量`tmp`，一个空的`List<String>`变量`ans`，以及两个计数器`left`和`right`，分别用于跟踪已经添加到`tmp`中的左括号和右括号的数量。
2. **检查是否可以添加左括号**：如果`left`小于`n`，则可以添加一个左括号。在`tmp`的末尾添加一个左括号，然后递归调用`backtrack`函数，`left`计数器加一。
3. **回溯**：在递归返回后，删除`tmp`末尾的字符，以便在下一次递归中使用正确的字符串。
4. **检查是否可以添加右括号**：如果`right`小于`left`，则可以添加一个右括号。在`tmp`的末尾添加一个右括号，然后递归调用`backtrack`函数，`right`计数器加一。
5. **回溯**：在递归返回后，删除`tmp`末尾的字符。
6. **检查是否找到一个有效的括号组合**：如果`tmp`的长度达到`2n`，则找到了一个有效的括号组合，将其添加到`ans`中。
7. **返回结果**：最后，返回`ans`，它包含了所有有效的括号组合。



**代码**

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList<>();
        backtrack(ans, new StringBuilder(), n, 0, 0);
        return ans;
    }
    public void backtrack(List<String> ans, StringBuilder tmp, int n, int left, int right) {
        if (tmp.length() == n * 2) {
            ans.add(tmp.toString());
            return;
        }
        if (left < n) {
            tmp.append('(');
            backtrack(ans, tmp, n, left + 1, right);
            tmp.deleteCharAt(tmp.length() - 1);
        }
        if (right < left) {
            tmp.append(')');
            backtrack(ans, tmp, n, left, right + 1);
            tmp.deleteCharAt(tmp.length() - 1);
        }
    }
}
```

**通过测试：**

`执行用时分布`：`0ms`			`击败100%使用 Java 的用户`

`消耗内存分布`：`41.90MB`	`击败54.63%使用 Java 的用户`
#### [Q79. 单词搜索](https://leetcode.cn/problems/word-search/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
输出：true
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
输出：false
```

 

##### 第一种思路：

**流程**

1. `exist`函数首先检查输入的二维网格是否为空，如果为空则直接返回`false`。
2. 然后，`exist`函数遍历二维网格中的每一个元素，对每一个元素调用`backtrack`函数。
3. `backtrack`函数是一个递归函数，它的目标是找到一个路径，使得路径上的字符按顺序构成目标单词。
4. 在`backtrack`函数中，首先检查当前的索引`idx`是否等于目标单词的长度，如果等于，说明已经找到了一个有效的路径，返回`true`。
5. 然后，检查当前的位置`(i, j)`是否在二维网格的范围内，以及当前位置的字符是否等于目标单词的第`idx`个字符，如果不满足这些条件，返回`false`。
6. 接下来，将当前位置的字符暂时替换为一个空格，以防止在后续的搜索中重复使用这个字符。
7. 然后，对当前位置的四个方向（上、下、左、右）进行遍历，对每一个方向，递归调用`backtrack`函数，如果返回`true`，说明找到了一个有效的路径，返回`true`。
8. 如果四个方向都没有找到有效的路径，将当前位置的字符恢复为原来的字符，然后返回`false`。
9. `exist`函数中，如果任何一个元素的`backtrack`函数返回`true`，则返回`true`，否则返回`false`。



**代码**

```java
class Solution {
    int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    public boolean exist(char[][] board, String word) {
        if (board == null || board.length == 0) {
            return false;
        }
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (backtrack(board, word, 0, i, j)) {
                    return true;
                }
            }
        }
        return false;
    }
    public boolean backtrack(char[][] board, String word, int idx, int i, int j) {
        if (idx == word.length()) {
            return true;
        }
        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word.charAt(idx)) {
            return false;
        }
        char tmp = board[i][j];
        board[i][j] = '\0';
        for (int[] direction : directions) {
            int di = i + direction[0];
            int dj = j + direction[1];
            if (backtrack(board, word, idx + 1, di, dj)) {
                return true;
            }
        }
        board[i][j] = tmp;
        return false;
    }
}
```

**通过测试：**

`执行用时分布`：`193ms`			`击败31.41%使用 Java 的用户`

`消耗内存分布`：`40.45MB`	`击败74.78%使用 Java 的用户`



##### 对代码进行优化

```java
public class Solution {
    public boolean exist(char[][] board, String word) {
        int m = board.length, n = board[0].length;
        boolean[][] visited = new boolean[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (backtrack(board, word, 0, i, j, visited)) {
                    return true;
                }
            }
        }
        return false;
    }
    public boolean backtrack(char[][] board, String word, int idx, int i, int j, boolean[][] visited) {
        if (idx == word.length()) {
            return true;
        }
        if (i < 0 ||
                i >= board.length ||
                j < 0 ||
                j >= board[0].length ||
                board[i][j] != word.charAt(idx) ||
                visited[i][j]) {
            return false;
        }
        visited[i][j] = true;
        if (backtrack(board, word, idx + 1, i - 1, j, visited) ||
                backtrack(board, word, idx + 1, i + 1, j, visited) ||
                backtrack(board, word, idx + 1, i, j - 1, visited) ||
                backtrack(board, word, idx + 1, i, j + 1, visited)) {
            return true;
        }
        visited[i][j] = false;
        return false;
    }
}
```

**通过测试：**

`执行用时分布`：`143ms`			`击败60.10%使用 Java 的用户`

`消耗内存分布`：`40.63MB`		`击败41.82%使用 Java 的用户`
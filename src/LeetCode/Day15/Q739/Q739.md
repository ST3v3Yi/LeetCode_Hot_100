#### [Q739. 每日温度](https://leetcode.cn/problems/daily-temperatures/?envType=study-plan-v2&envId=top-100-liked)

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

 

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

**示例 2:**

```
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

**示例 3:**

```
输入: temperatures = [30,60,90]
输出: [1,1,0]
```

 

##### 第一种思路：

最简单的想法

**代码**

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int[] ans = new int[temperatures.length];
        for (int i = 0; i < temperatures.length; i++) {
            Stack<Integer> stack = new Stack<>();
            boolean lock = false;
            for (int j = i; j < temperatures.length; j++) {
                if (temperatures[j] <= temperatures[i]) {
                    stack.push(temperatures[j]);
                } else {
                    lock = true;
                    break;
                }
            }
            if (lock) {
                ans[i] = stack.size();
            } else {
                ans[i] = 0;
            }
        }
        return ans;
    }
}
```

<font style="color: red;">**超出时间限制**</font>



##### 第二种思路：利用栈进行优化

**代码**

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int[] ans = new int[temperatures.length];
        Stack<Integer> stack = new Stack<>(); // 使用栈存储温度数组的索引
        for (int i = 0; i < temperatures.length; i++) {
            // 如果栈非空且当前温度比栈顶索引对应的温度高
            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
                int prevIndex = stack.pop(); // 弹出栈顶索引
                ans[prevIndex] = i - prevIndex; // 更新栈顶索引对应的结果
            }
            stack.push(i); // 当前温度的索引入栈
        }
        return ans;
    }
}
```

**通过测试：**

`执行用时分布`：`168ms`			`击败30.01%使用 Java 的用户`

`消耗内存分布`：`61.49MB`	`击败11.31%使用 Java 的用户`



**备注**

若是将 `Stack<Integer> stack = new Stack<>();` 改为 `Deque<Integer> stack = new LinkedList<Integer>();` 

**通过测试：**

`执行用时分布`：`24ms`			`击败87.68%使用 Java 的用户`

`消耗内存分布`：`57.82MB`	`击败68.83%使用 Java 的用户`
#### [Q131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/?envType=study-plan-v2&envId=top-100-liked)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 

**回文串**

 。返回 `s` 所有可能的分割方案。



 

**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

**示例 2：**

```
输入：s = "a"
输出：[["a"]]
```

 

##### 第一种思路：动态规划+回溯

**流程思路**

1. **动态规划建模**：首先，使用动态规划将问题建模成一个二维数组 `dp`。其中 `dp[i][j]` 表示从字符串的第 `i` 个字符到第 `j` 个字符是否为回文串。使用动态规划技术来填充这个数组，以确定所有可能的回文子串。
2. **回溯法**：得到了回文串的二维数组 `dp`，就可以使用回溯法来找到所有可能的分割方式。可以从字符串的开头开始，尝试不同的切割点。如果在位置 `i` 切割了字符串，并且 `dp[0][i]` 为真，那么这个切割点是有效的。可以将已经找到的有效切割点保存在一个列表中，并继续寻找下一个切割点。当遍历完整个字符串时，就能得到所有可能的切割方式。
3. **递归与回溯**：在实现过程中，可以使用递归和回溯来找到所有可能的切割方式。递归函数可以帮助我们不断尝试不同的切割点，而回溯机制可以确保我们在不同的分支之间切换，并且在每个分支上进行回溯，以找到所有可能的结果。

**代码**

```java
class Solution {
    public List<List<String>> partition(String s) {
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        List<List<String>> ans = new ArrayList<>();
        List<String> curr = new ArrayList<>();
        for (int end = 0; end < n; end++) {
            for (int start = 0; start < n; start++) {
                if (s.charAt(start) == s.charAt(end) && (end - start <= 2 || dp[start + 1][end - 1])) {
                    dp[start][end] = true;
                }
            }
        }
        partitionHelper(s, 0, dp, curr, ans);
        return ans;
    }
    public void partitionHelper(String s, int start, boolean[][] dp, List<String> curr, List<List<String>> ans) {
        if (start == s.length()) {
            ans.add(new ArrayList<>(curr));
            return;
        }
        for (int end = start; end < s.length(); end++) {
            if (dp[start][end]) {
                curr.add(s.substring(start, end + 1));
                partitionHelper(s, end + 1, dp, curr, ans);
                curr.remove(curr.size() - 1);
            }
        }
    }
}
```

**通过测试：**

`执行用时分布`：`7ms`			`击败95.80%使用 Java 的用户`

`消耗内存分布`：`55.91MB`	`击败17.13%使用 Java 的用户`
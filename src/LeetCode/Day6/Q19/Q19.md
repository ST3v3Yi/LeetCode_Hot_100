#### [Q19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

**示例 2：**

```
输入：head = [1], n = 1
输出：[]
```

**示例 3：**

```
输入：head = [1,2], n = 1
输出：[1]
```

 

##### 第一种思路：快慢指针

快指针先行 `n` 步后，慢指针再和快指针同行，直到快指针指向链表最后一个结点。

慢指针跳过一个结点，即：`slow.next = slow.next.next`

难点在于判断 **删除头节点**

代码：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 判断链表是否为空或只有一个节点，或者需要删除的是头节点
        if (head == null || (head.next == null && n == 1)) {
            return null;
        }

        // 初始化快指针和慢指针，均指向链表头节点
        ListNode fast = head; // 快指针，用于先行移动n步
        ListNode slow = head; // 慢指针，用于定位需要删除节点的前一个节点

        // 快指针先向前移动n个节点
        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }

        // 如果快指针为空，说明要删除的是头节点，直接返回头节点的下一个节点
        if (fast == null) {
            return head.next;
        }

        // 移动快慢指针，直到快指针指向链表末尾的下一个节点
        while (fast.next != null) {
            slow = slow.next;
            fast = fast.next;
        }

        // 删除慢指针的下一个节点（即要删除的节点）
        slow.next = slow.next.next;

        // 返回头节点
        return head;
    }
}
```

**通过测试：**

`执行用时分布`：`0ms`			`击败100%使用 Java 的用户`

`消耗内存分布`：`40.64MB`	`击败46.55%使用 Java 的用户`


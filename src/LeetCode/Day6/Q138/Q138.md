#### [Q138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/?envType=study-plan-v2&envId=top-100-liked)

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

- `val`：一个表示 `Node.val` 的整数。
- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

**示例 3：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png)**

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

 

##### 第一种思路：

整体过程分为**3**步：

将复制的链表结点先参照原链表的next：
$$
A \rightarrow B \rightarrow C\\
$$
转换成：
$$
a \rightarrow b \rightarrow c\\
$$
然后将原链表各个结点的next指向新链表的对应节点，即：
$$
A \rightarrow a\\
B \rightarrow b\\
C \rightarrow c\\
$$
这样就可以让新链表的 `random` 指向对应的结点，即：`a.random = A.random.next`

```
假设原链表为A-B-C，复制出的链表为a-b-c，方法如下：
	1.先按照原链表next的方向，将新链表的next设置完毕，使其成为a-b-c
	2.然后让原链表结点的next指向新链表对应的结点，即：A.next = a
	3.最后就可以实现a.random =  A.random.next，从而定义新链表结点的random
```

*在实践中可以发现，采用上述方法会导致设定的变量过多，因为进行每项操作都要从头结点开始，同时这也会导致超出时间限制！*



**因此对上述方法进行优化：**

```
假设原链表为A-B-C，复制出的链表为a-b-c，方法如下：
	1.将新节点插入到原节点后，使其成为A-a-B-b-C-c；
	2.然后设置新节点的random，使 a.random = A.random.next；
	3.最后把原节点和新节点分开为两个链表。
```

代码：

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
        if (head == null)
            return null;
        // 创建复制的新链表，将新节点插入到每个原节点的后面
        Node curr = head;
        while (curr != null) {
            Node newNode = new Node(curr.val);
            newNode.next = curr.next;
            curr.next = newNode;
            curr = newNode.next;
        }
        // 设置复制节点的 random 指针
        curr = head;
        while (curr != null) {
            if (curr.random != null) {
                curr.next.random = curr.random.next;
            }
            curr = curr.next.next;
        }
        // 拆分原链表和复制链表
        curr = head;
        Node newHead = head.next;
        while (curr != null) {
            Node temp = curr.next;
            curr.next = temp.next;
            if (temp.next != null) {
                temp.next = temp.next.next;
            }
            curr = curr.next;
        }
        return newHead;
    }
}
```

**通过测试：**

`执行用时分布`：`0ms`			`击败100%使用 Java 的用户`

`消耗内存分布`：`43.32MB`	`击败49.61%使用 Java 的用户`
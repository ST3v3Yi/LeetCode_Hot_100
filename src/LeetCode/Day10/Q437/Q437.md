#### [Q437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/?envType=study-plan-v2&envId=top-100-liked)

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。



**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

**示例 2：**

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3
```

 

##### 第一种思路：

对树进行深度优先搜索，在遍历的过程中记录和的大小，并记录能达到目标值分支的个数。

**思路与算法**

我们首先想到的解法是穷举所有的可能，我们访问每一个节点 $node$ ，检测以 $node$ 为起始节点且向下延深的路径有多少种。我们递归遍历每一个节点的所有可能的路径，然后将这些路径数目加起来即为返回结果。

* 我们首先定义 $rootSum(p,val)$ 表示以节点 p 为起点向下且满足路径总和为 $val$ 的路径数目。我们对二叉树上每个节点 $p$ 求出 $rootSum(p,targetSum)$ ，然后对这些路径数目求和即为返回结果。
* 我们对节点 $p$ 求 $rootSum(p,targetSum)$ 时，以当前节点 p 为目标路径的起点递归向下进行搜索。假设当前的节点 p 的值为 val，我们对左子树和右子树进行递归搜索，对节点 p 的左孩子节点 $p_{l}$ 求出 $rootSum(pl,targetSum−val)$ ，以及对右孩子节点 $p_{r}$ 求出 $rootSum(pr,targetSum−val)$ 。节点 $p$ 的 $rootSum(p,targetSum)$ 即等于 $rootSum(pl,targetSum−val)$ 与 $rootSum(pr,targetSum−val)$ 之和，同时我们还需要判断一下当前节点 $p$ 的值是否刚好等于 $targetSum$。

* 我们采用递归遍历二叉树的每个节点 $p$ ，对节点 $p$ 求 $rootSum(p,val)$，然后将每个节点所有求的值进行相加求和返回。

**代码：**

```java
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return 0;
        }

        int ret = rootSum(root, targetSum);
        ret += pathSum(root.left, targetSum);
        ret += pathSum(root.right, targetSum);
        return ret;
    }

    public int rootSum(TreeNode root, int targetSum) {
        int ret = 0;

        if (root == null) {
            return 0;
        }
        int val = root.val;
        if (val == targetSum) {
            ret++;
        } 

        ret += rootSum(root.left, targetSum - val);
        ret += rootSum(root.right, targetSum - val);
        return ret;
    }
}
```



##### 第二种思路：前缀和

思路与算法

我们仔细思考一下，解法一中应该存在许多重复计算。我们定义节点的前缀和为：由根结点到当前结点的路径上所有节点的和。我们利用先序遍历二叉树，记录下根节点 $root$ 到当前节点 $p$ 的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和 $curr$ 减去 $targetSum$ 。

对于空路径我们也需要保存预先处理一下，此时因为空路径不经过任何节点，因此它的前缀和为 $0$。

假设根节点为 $root$ ，我们当前刚好访问节点 $node$，则此时从根节点 $root$ 到节点 $node$ 的路径（无重复节点）刚好为 $root→p1→p2→…→pk→node$，此时我们可以已经保存了节点 $p_1, p_2, p_3, \ldots, p_k$ 的前缀和，并且计算出了节点 $node$ 的前缀和。

假设当前从根节点 $root$ 到节点 $node$ 的前缀和为 $curr$，则此时我们在已保存的前缀和查找是否存在前缀和刚好等于 $curr−targetSum$ 。假设从根节点 $root$ 到节点 $node$ 的路径中存在节点 $p_i$ 到根节点 $root$ 的前缀和为 $curr−targetSum$ ，则节点$p_{i+1}$ 到 $node$ 的路径上所有节点的和一定为 $targetSum$。

我们利用深度搜索遍历树，当我们退出当前节点时，我们需要及时更新已经保存的前缀和。

**代码：**

```java
class Solution {
    /**
     * 计算二叉树中路径和等于给定目标和的路径数量。
     *
     * @param root 二叉树的根节点。
     * @param targetSum 目标和。
     * @return 路径和等于目标和的路径数量。
     */
    public int pathSum(TreeNode root, int targetSum) {
        // 初始化一个 HashMap 用于存储前缀和及其计数。
        Map<Long, Integer> map = new HashMap<>();
        // 将初始路径和为 0 的情况放入 HashMap 中。
        map.put(0L, 1);

        // 调用辅助函数进行深度优先搜索，并计算路径数量。
        return dfs(root, 0L, targetSum, map);
    }

    /**
     * 辅助函数，对二叉树进行深度优先搜索。
     *
     * @param root 当前遍历的节点。
     * @param currSum 当前路径的和。
     * @param target 目标和。
     * @param map 前缀和及其计数的哈希表。
     * @return 路径和等于目标和的路径数量。
     */
    public int dfs(TreeNode root, Long currSum, int target, Map<Long, Integer> map) {
        // 如果当前节点为空，返回 0。
        if (root == null)
            return 0;

        // 初始化一个变量来存储满足条件的路径数量。
        int ret = 0;
        // 更新当前路径和，加上当前节点的值。
        currSum += root.val;
        // 获取前缀和中与当前路径和的差等于目标和的路径数量。
        ret = map.getOrDefault(currSum - target, 0);
        // 将当前路径和及其计数放入哈希表中。
        map.put(currSum, map.getOrDefault(currSum, 0) + 1);

        // 递归遍历左右子树，并累加满足条件的路径数量。
        ret += dfs(root.left, currSum, target, map);
        ret += dfs(root.right, currSum, target, map);

        // 回溯：将当前路径和的计数减 1。
        map.put(currSum, map.get(currSum) - 1);

        // 返回满足条件的路径数量。
        return ret;
    }
}
```

**通过测试：**

`执行用时分布`：`3ms`			`击败97.14%使用 Java 的用户`

`消耗内存分布`：`43.32MB`	`击败20.83%使用 Java 的用户`
#### [Q4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/submissions/511278748/?envType=study-plan-v2&envId=top-100-liked)

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

 

**示例 1：**

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

**示例 2：**

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

 

##### 第一种思路：

**思路**

合并两个已排序的数组 `nums1` 和 `nums2`，然后找到合并后数组的中位数

**代码**

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n = nums1.length + nums2.length;
        List<Integer> nums = new ArrayList<>();
        int i = 0, j = 0;
        while (i < nums1.length && j < nums2.length) {
            if (nums1[i] < nums2[j]) {
                nums.add(nums1[i]);
                i++;
            } else {
                nums.add(nums2[j]);
                j++;
            }
        }
        while (j < nums2.length) {
            nums.add(nums2[j++]);
        }
        while (i < nums1.length) {
            nums.add(nums1[i++]);
        }
        if (n % 2 == 0) {
            return (double)(nums.get(n / 2) + nums.get(n / 2 - 1)) / 2;
        }
        return (double)nums.get(n / 2);
    }
}
```

**通过测试：**

`执行用时分布`：`2ms`			`击败27.54%使用 Java 的用户`

`消耗内存分布`：`44.98MB`	`击败11.93%使用 Java 的用户`



##### 第二种思路：二分查找

**思路**

1. 假设两个数组分别为 `nums1` 和 `nums2`，长度分别为 `m` 和 `n`。
2. 在较短的数组上执行二分查找，假设为 `nums1`。
3. 在 `nums1` 中选择一个分割点 `i`，使得 `i` 左侧的元素个数加上 `nums2` 中左侧元素的个数等于中位数左侧元素的总数。即满足以下条件：
   - `left_part = (m + n + 1) / 2`，其中 `left_part` 表示中位数左侧元素的个数，`(m + n + 1)` 为奇数时，左侧元素比右侧元素多一个。
   - `nums1[i-1] <= nums2[j]` 且 `nums2[j-1] <= nums1[i]`，其中 `j = left_part - i` 表示 `nums2` 中的分割点。
4. 根据分割点 `i` 和 `j`，确定中位数：
   - 如果 `(m + n)` 是奇数，则中位数为 `max(nums1[i-1], nums2[j-1])`。
   - 如果 `(m + n)` 是偶数，则中位数为 `(max(nums1[i-1], nums2[j-1]) + min(nums1[i], nums2[j])) / 2`。

**代码**

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        if (nums1.length > nums2.length) {
            return findMedianSortedArrays(nums2, nums1);
        }
        int m = nums1.length;
        int n = nums2.length;
        int left = 0;
        int right = m;
        int halfLen = (m + n + 1) / 2;
        while (left < right) {
            int i = (right + left) / 2;
            int j = halfLen - i;
            if (i < m && nums2[j - 1] > nums1[i]) {
                left = i + 1;
            } else {
                right = i;
            }
        }
        int i = left;
        int j = halfLen - left;
        int num1LeftMax = (i == 0) ? Integer.MIN_VALUE : nums1[i - 1];
        int num1RightMin = (i == m) ? Integer.MAX_VALUE : nums1[i];
        int num2LeftMax = (j == 0) ? Integer.MIN_VALUE : nums2[j - 1];
        int num2RightMin = (j == n) ? Integer.MAX_VALUE : nums2[j];
        if ((m + n) % 2 == 1) {
            return Math.max(num1LeftMax, num2LeftMax);
        } else {
            return (double) (Math.max(num1LeftMax, num2LeftMax) + Math.min(num1RightMin, num2RightMin)) / 2;
        }
    }
}
```

**通过测试：**

`执行用时分布`：`1ms`			`击败100%使用 Java 的用户`

`消耗内存分布`：`44.87MB`	`击败34.93%使用 Java 的用户`
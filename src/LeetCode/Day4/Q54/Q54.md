#### [Q54.螺旋数组](https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

**示例 1：**

![spiral1](./spiral1.jpg)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**示例 2：**

![spiral2](./spiral2.jpg)

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

 

##### 第一种思路：

将数组看作迷宫，借用动态规划的思想，将螺旋过程设定为走迷宫的过程。

其本身的走迷宫的规则为：右、下、左、上

代码：

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> list = new ArrayList<>();
        int i = 0, j = 0;   // 初始位置
        int row = matrix.length;  // row
        int col = matrix[0].length; // col
        int Nodes = row * col;  // 节点数，用来判断循环结束与否
        while (Nodes > 0) {
            list.add(matrix[i][j]);
            matrix[i][j] = 101;
            if (j < col - 1 && matrix[i][j+1] != 101) {
                j++;
            } else if (i < row - 1 && matrix[i+1][j] != 101) {
                i++;
            } else if (j > 0 && matrix[i][j-1] != 101) {
                j--;
            } else if (i > 0 && matrix[i-1][j] != 101){
                i--;
            }
            Nodes--;
        }
        return list;
    }
}
```

该代码存在问题，即：其没有直接走到头，遇到4*4的数组时会提前向右走（向右走的优先级高于向左走）

```
matrix =[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]
输出：[1,2,3,4,8,12,16,15,14,13,9,10,11,7,6,5]
预期结果：[1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10]
```

解决思路：即将条件下的 `i` 与 `j` 的变化改为循环输出，使其一次走到头。

修改后代码：

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> list = new ArrayList<>();
        int i = 0, j = 0;   // 初始位置应该是 (0, 0)
        int row = matrix.length;  // 行数
        int col = matrix[0].length; // 列数
        int Nodes = row * col;  // 节点数，用来判断循环结束与否
        list.add(matrix[0][0]);
        matrix[0][0] = 101; // 标记已经访问过的节点为 101
        while (Nodes > 1) { // 循环终止条件改为判断是否还有节点未访问
            if (j < col - 1 && matrix[i][j+1] != 101) { // 向右
                while (j < col - 1 && matrix[i][j+1] != 101) {
                    j++;
                    list.add(matrix[i][j]);
                    matrix[i][j] = 101;
                    Nodes--;
                }
            }
            if (i < row - 1 && matrix[i+1][j] != 101) { // 向下
                while (i < row - 1 && matrix[i+1][j] != 101) {
                    i++;
                    list.add(matrix[i][j]);
                    matrix[i][j] = 101;
                    Nodes--;
                }
            }
            if (j > 0 && matrix[i][j-1] != 101) { // 向左
                while (j > 0 && matrix[i][j-1] != 101) {
                    j--;
                    list.add(matrix[i][j]);
                    matrix[i][j] = 101;
                    Nodes--;
                }
            }
            if (i > 0 && matrix[i-1][j] != 101) { // 向上
                while (i > 0 && matrix[i-1][j] != 101) {
                    i--;
                    list.add(matrix[i][j]);
                    matrix[i][j] = 101;
                    Nodes--;
                }
            }
        }
        return list;
    }
}
```

**通过测试：**

`执行用时分布`：`0ms`			`击败100%使用 Java 的用户`

`消耗内存分布`：`40.43MB`	`击败60.53%使用 Java 的用户`



##### 第二种思路：按层模拟

可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。

定义矩阵的第 k 层是到最近边界距离为 k的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2层，剩下的元素都是第 3 层。

```
[[1, 1, 1, 1, 1, 1, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 2, 3, 3, 3, 2, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 1, 1, 1, 1, 1, 1]]
```

对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于 `(top,left)`，右下角位于 `(bottom,right)`，按照如下顺序遍历当前层的元素。

从左到右遍历上侧元素，依次为 `(top,left)` 到 `(top,right)` 。

从上到下遍历右侧元素，依次为 `(top+1,right)` 到 `(bottom,right)`。

如果 `left < right` 且 `top < bottom`，则从右到左遍历下侧元素，依次为 `(bottom,right−1)` 到 `(bottom,left+1)`，以及从下到上遍历左侧元素，依次为 `(bottom,left)` 到 `(top+1,left)`。

遍历完当前层的元素之后，将 `left` 和 `top` 分别增加 1，将 `right` 和 `bottom` 分别减少 1，进入下一层继续遍历，直到遍历完所有元素为止。

![Q54](.\Q54.png)

代码：

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> order = new ArrayList<Integer>();
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return order;
        }
        int rows = matrix.length, columns = matrix[0].length;
        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;
        while (left <= right && top <= bottom) {
            for (int column = left; column <= right; column++) {
                order.add(matrix[top][column]);
            }
            for (int row = top + 1; row <= bottom; row++) {
                order.add(matrix[row][right]);
            }
            if (left < right && top < bottom) {
                for (int column = right - 1; column > left; column--) {
                    order.add(matrix[bottom][column]);
                }
                for (int row = bottom; row > top; row--) {
                    order.add(matrix[row][left]);
                }
            }
            left++;
            right--;
            top++;
            bottom--;
        }
        return order;
    }
}
```

空间复杂度为：`O(1)` ，相较于第一种思路的 `O(mn)` 已经大幅优化了。

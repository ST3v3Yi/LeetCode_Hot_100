#### [Q101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/?envType=study-plan-v2&envId=top-100-liked)

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**示例 1：**

![img](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

![img](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

 

##### 第一种思路：

如果对示例1中的树作中序遍历，得到的结果为：[3, 2, 4, 1, 4, 2, 3]

因此可以对其中序遍历的结果作判断。

代码：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        List<Integer> inorderList = new ArrayList<>();
        inorder(root, inorderList);
        int mid = (inorderList.size() - 1) / 2;
        int left = mid - 1, right = mid + 1;
        while (left >= 0 && right < inorderList.size()) {
            if (inorderList.get(left) != inorderList.get(right)) {
                return false;
            }
            left--;
            right++;
        }
        return true;
    }
    public void inorder(TreeNode root, List res) {
        if (root == null)
            return;
        inorder(root.left, res);
        res.add(root.val);
        inorder(root.right, res);
    }
}
```

该代码对于节点的判断机制是根据其 $val$ ，但是实际上遇到用例 `root=[1,2,2,2,null,2]` 的情况下，难以判断是否相等，于是做出调整，将 `List` 存储元素的类型从 `Integer` 改为 `TreeNode` ，这样对结点的比对会好一点吗？

但是，实际上这又出现了问题，即：左右节点因为轴对称的缘故，其子节点是镜像的，这就导致左节点的右子节点对应的是右节点的左子节点，这会导致判断失误。

那不妨，定义新的树，其相对于原树进行翻转，若二者相同，则二叉树对称。

代码：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        TreeNode copy = copyTree(root);
        invert(copy);
        return isSameTree(root, copy);
    }

    // 判断两棵树是否相同
    public boolean isSameTree(TreeNode p, TreeNode q) {
        // 如果两个树的根节点都为空，则认为它们相等
        if (p == null && q == null)
            return true;
        // 如果两个树中有且仅有一个根节点为空，则认为它们不相等
        if (p == null || q == null)
            return false;
        // 如果两个树的根节点的值不相等，则认为它们不相等
        if (p.val != q.val)
            return false;
        // 递归地比较两棵树的左子树和右子树
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }

    // 复制一棵树
    public TreeNode copyTree(TreeNode root) {
        if (root == null)
            return null;
        TreeNode copyRoot = new TreeNode(root.val);
        copyRoot.left = copyTree(root.left);
        copyRoot.right = copyTree(root.right);
        return copyRoot;
    }

    // 翻转树的结构
    public void invert(TreeNode root) {
        if (root == null)
            return;
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        invert(root.left);
        invert(root.right);
    }
}
```

**通过测试：**

`执行用时分布`：`0ms`			`击败100%使用 Java 的用户`

`消耗内存分布`：`40.78MB`	`击败33.52%使用 Java 的用户`



##### 第二种思路：递归

如果一个树的左子树与右子树镜像对称，那么这个树是对称的。

![fig1](https://assets.leetcode-cn.com/solution-static/101/101_fig1.PNG)

因此，该问题可以转化为：两个树在什么情况下互为镜像？

如果同时满足下面的条件，两个树互为镜像：

- 它们的两个根结点具有相同的值
- 每个树的右子树都与另一个树的左子树镜像对称

![fig2](https://assets.leetcode-cn.com/solution-static/101/101_fig2.PNG)


我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，$p$ 指针和 $q$ 指针一开始都指向这棵树的根，随后 $p$ 右移时，$q$ 左移，$p$ 左移时，$q$ 右移。每次检查当前 $p$ 和 $q$ 节点的值是否相等，如果相等再判断左右子树是否对称。

代码：

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root, root);
    }

    public boolean check(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        }
        if (p == null || q == null) {
            return false;
        }
        return p.val == q.val && check(p.left, q.right) && check(p.right, q.left);
    }
}
```

**通过测试：**

`执行用时分布`：`0ms`			`击败100%使用 Java 的用户`

`消耗内存分布`：`40.64MB`	`击败58.73%使用 Java 的用户`
#### [Q994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/description/?envType=study-plan-v2&envId=top-100-liked)

在给定的 `m x n` 网格 `grid` 中，每个单元格可以有以下三个值之一：

- 值 `0` 代表空单元格；
- 值 `1` 代表新鲜橘子；
- 值 `2` 代表腐烂的橘子。

每分钟，腐烂的橘子 **周围 4 个方向上相邻** 的新鲜橘子都会腐烂。

返回 *直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`* 。



**示例 1：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png)**

```
输入：grid = [[2,1,1],[1,1,0],[0,1,1]]
输出：4
```

**示例 2：**

```
输入：grid = [[2,1,1],[0,1,1],[1,0,1]]
输出：-1
解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。
```

**示例 3：**

```
输入：grid = [[0,2]]
输出：0
解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。
```



##### 第一种思路：

**思路**

每次遍历存储已经腐烂的橘子的位置，将其附近的完好的橘子标记为腐烂，并将其本身标记为访问过，当整个过程无法再感染到完好的橘子时结束。

**算法（整体过程可以参考Q200中的BFS解决问题的方式）**

1. 首先，遍历整个网格，将所有已经腐烂的橘子的位置加入到队列中，并将它们标记为已访问过。
2. 开始BFS遍历：从队列中取出一个腐烂的橘子位置，将其周围未腐烂的橘子标记为腐烂，并将它们加入到队列中，并标记为已访问过。
3. 继续从队列中取出未访问过的腐烂橘子，重复上述过程，直到队列为空，表示无法再感染到新的橘子为止。

**代码：**

```java
class Solution {
    public int orangesRotting(int[][] grid) {
        if (grid == null || grid.length == 0) {
            return -1;
        }
        int time = 0;
        int row = grid.length;
        int col = grid[0].length;
        int freshOrange = 0;
        Queue<Integer> RottedOranges = new ArrayDeque<>();
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (grid[i][j] == 2) {
                    RottedOranges.add(i * col + j); // 存储腐烂橘子的位置
                } else if (grid[i][j] == 1) {
                    freshOrange++;
                }
            }
        }
        while (!RottedOranges.isEmpty() && freshOrange > 0) {
            int size = RottedOranges.size();
            for (int i = 0; i < size; i++) {
                int num = RottedOranges.poll();
                int r = num / col;   // row
                int c = num % col;   // col
                if (r - 1 >=0 && grid[r-1][c] == 1) {
                    grid[r-1][c] = 2;
                    RottedOranges.add((r-1)*col + c);
                    freshOrange--;
                }
                if (r + 1 <= row - 1 && grid[r+1][c] == 1) {
                    grid[r+1][c] = 2;
                    RottedOranges.add((r+1)*col + c);
                    freshOrange--;
                }
                if (c - 1 >= 0 && grid[r][c-1] == 1) {
                    grid[r][c-1] = 2;
                    RottedOranges.add(r*col + c - 1);
                    freshOrange--;
                }
                if (c + 1 <= col - 1 && grid[r][c+1] == 1) {
                    grid[r][c+1] = 2;
                    RottedOranges.add(r*col + c + 1);
                    freshOrange--;
                }
            }
            if (!RottedOranges.isEmpty())
                time++;
        }
        return freshOrange == 0 ? time : -1;
    }
}
```

**通过测试：**

`执行用时分布`：`1ms`			`击败99.96%使用 Java 的用户`

`消耗内存分布`：`41.00MB`	`击败83.02%使用 Java 的用户`
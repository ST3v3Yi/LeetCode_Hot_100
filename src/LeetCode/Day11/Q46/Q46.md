#### [Q46. 全排列](https://leetcode.cn/problems/permutations/?envType=study-plan-v2&envId=top-100-liked)

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。



**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```
输入：nums = [1]
输出：[[1]]
```



##### 第一种思路：

**过程**

1. 主函数 `permute` 接收一个整数数组 `nums` 作为参数，并返回一个包含所有排列的列表 `res`。

2. 在主函数中创建一个空列表 `tmp` 作为临时列表，用于存储当前正在生成的排列。

3. 调用 `backtrack` 函数进行递归生成排列，并将结果存储在 `res` 列表中。

4. ```
   backtrack
   ```

    函数定义了递归生成排列的具体逻辑：

   - 如果当前排列的长度等于给定数组的长度，说明已经生成了一个完整的排列，将当前排列加入到结果集中，并返回。
   - 遍历给定数组中的所有元素：
     - 如果当前元素已经在临时列表中，说明已经使用过，跳过当前元素。
     - 否则，将当前元素添加到临时列表中，然后递归调用 `backtrack` 函数生成下一个位置的元素。
     - 递归调用结束后，将最后添加的元素移出临时列表，进行回溯。

5. 当递归函数执行完毕后，主函数返回结果集 `res`，其中包含了给定数组的所有排列。

**代码：**

```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> tmp = new ArrayList<>();
        backtrack(res, tmp, nums);
        return res;
    }
    public void backtrack(List<List<Integer>> res, List<Integer> tmp, int[] nums) {
        if (tmp.size() == nums.length) {
            res.add(new ArrayList<>(tmp));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if (tmp.contains(nums[i])) {
                continue;
            }
            tmp.add(nums[i]);
            backtrack(res, tmp, nums);
            tmp.remove(tmp.size() - 1);
        }
    }
}
```

**通过测试：**

`执行用时分布`：`1ms`			`击败91.51%使用 Java 的用户`

`消耗内存分布`：`43.38MB`	`击败59.99%使用 Java 的用户`
#### Q56.合并区间

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

#####  第一种思路：双指针

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        // 确定ans的长度n
        int n = intervals.length;
        for (int i = 0; i < intervals.length-1; i++){
            if (intervals[i][1] >= intervals[i+1][0]){
                n--;
            }
        }
        // 获取ans
        int[][] ans = new int[n][2];
        /*
        * 双指针i和j
        * 其中，i始终指向ans对应的位置，方便插入数值
        * j始终对intervals中的数值进行判断并执行相应的跳过机制
        * */
        int j = 0;
        for (int i = 0; i < n; i++){
            ans[i][0] = intervals[j][0];
            if (j < intervals.length - 1 && intervals[j][1] >= intervals[j+1][0]){
                j++;
                ans[i][1] = intervals[j][1];
            } else {
                ans[i][1] = intervals[j][1];
            }
            j++;
        }
        System.out.println(n);
        return ans;
    }
}
```

面对用例：

```
intervals = [[1,4],[0,4]], 预期结果：[[0,4]]
```

得到的结果为：[[1, 4]]

出现该问题的本质原因是因为我默认intervals是按照各个元素中start位置的大小进行排序的。

修改后代码：

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        // 按照intervals中各元素的start位置的大小进行排序
        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));
        // 确定ans的长度n
        int n = intervals.length;
        for (int i = 0; i < intervals.length-1; i++){
            if (intervals[i][1] >= intervals[i+1][0]){
                n--;
            }
        }
        // 获取ans
        int[][] ans = new int[n][2];
        /*
        * 双指针i和j
        * 其中，i始终指向ans对应的位置，方便插入数值
        * j始终对intervals中的数值进行判断并执行相应的跳过机制
        * */
        int j = 0;
        for (int i = 0; i < n; i++){
            ans[i][0] = intervals[j][0];
            if (j < intervals.length - 1 && intervals[j][1] >= intervals[j+1][0]){
                j++;
                ans[i][1] = intervals[j][1];
            } else {
                ans[i][1] = intervals[j][1];
            }
            j++;
        }
        return ans;
    }
}
```

修改后面对用例：

```
intervals = [[1,4],[2,3]], 预期结果：[[1,4]]
```

又出现了问题，本质原因是没有判断i的end位置与j的end位置的大小关系，需要添加新的判断条件

修改后代码：

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        // 按照intervals中各元素的start位置的大小进行排序
        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));
        // 确定ans的长度n
        int n = intervals.length;
        for (int i = 0; i < intervals.length-1; i++){
            if (intervals[i][1] >= intervals[i+1][0]){
                n--;
            }
        }
        // 获取ans
        int[][] ans = new int[n][2];
        /*
        * 双指针i和j
        * 其中，i始终指向ans对应的位置，方便插入数值
        * j始终对intervals中的数值进行判断并执行相应的跳过机制
        * */
        int j = 0;
        for (int i = 0; i < n; i++){
            ans[i][0] = intervals[j][0];
            // 添加新的判断条件 intervals[j][1] < intervals[j+1][1]
            if (j < intervals.length - 1 && intervals[j][1] >= intervals[j+1][0] && intervals[j][1] < intervals[j+1][1]){
                j++;
                ans[i][1] = intervals[j][1];
            } else {
                ans[i][1] = intervals[j][1];
            }
            j++;
        }
        return ans;
    }
}
```

修改后面对用例：

```
intervals = [[1,4],[0,2],[3,5]], 预期结果：[[0,5]]
```

遇到该问题，本质说明了目前的代码在面对多重修改时不能及时更新，即n限制了更新的可能。

可以这样理解：

n一开始就限制了循环的次数，导致ans最多只能接触到intervals的0-1，而2却难以接触到，如果想解决该问题，~~我们只能在采用for循环的方法，对intervals中的判断进行多次判定，来找到最大的end；~~

~~或许不需要for循环，我们判断到`j < intervals.length - 1 && intervals[j][1] >= intervals[j+1][0] && intervals[j][1] < intervals[j+1][1]`的条件时，不要先基于进行赋值，而是去尝试寻找更大的`intervals[j][1]`~~

本质上还是循环...

```
你的代码主要功能是合并重叠的区间。问题出在合并区间时的逻辑判断上。

在你的代码中，当判断到相邻区间有重叠时，你只是更新了`ans[i][1]`，而没有更新`ans[i][0]`。因此在最后返回结果时，`ans[i][0]` 的值可能是不正确的。

另外，你的内层循环应该遍历整个`intervals`数组来查找重叠区间，而不是仅在发现重叠时递增`j`。这样可以确保每个区间都被正确处理。
```



##### 第二种思路：在第一种思路的基础上进行简化优化

**优化方面：**

​	1.利用List来存储合并后的区间，避免了数组长度n对于循环的限制。

​	2.简化了判断条件，本质上也是list带来的好处

**代码：**

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        // 按照intervals中各元素的start位置的大小进行排序
        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));
        // 使用列表存储合并后的区间
        List<int[]> merged = new ArrayList<>();
        // 遍历所有区间
        for (int[] interval : intervals) {
            // 如果合并后的区间列表为空，或当前区间的起始位置大于列表中最后一个区间的终止位置，则直接将当前区间加入列表
            if (merged.isEmpty() || interval[0] > merged.get(merged.size() - 1)[1]) {
                merged.add(interval);
            } else {
                // 否则，更新列表中最后一个区间的终止位置为当前区间的终止位置
                merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], interval[1]);
            }
        }
        // 将列表转换为数组并返回
        return merged.toArray(new int[merged.size()][]);
    }
}
```

**通过测试：**

`执行用时分布`：`9ms`				`击败15.91%使用 Java 的用户`

`消耗内存分布`：`45.59MB`	    `击败22.06%使用 Java 的用户`

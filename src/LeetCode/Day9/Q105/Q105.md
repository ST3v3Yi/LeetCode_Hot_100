#### [Q105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/?envType=study-plan-v2&envId=top-100-liked)

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。



**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

**示例 2:**

```
输入: preorder = [-1], inorder = [-1]
输出: [-1]
```

 

##### 第一种思路：

1. 根据前序遍历序列找到根节点。
2. 根据根节点在中序遍历序列中的位置，将中序遍历序列分成左子树和右子树两部分。
3. 递归地构造左子树和右子树。
4. 将左子树和右子树分别连接到根节点的左右子节点上。

代码：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        // 利用递归函数构造二叉树
        return buildTreeHelper(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
    }

    private TreeNode buildTreeHelper(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) {
        // 递归终止条件：如果前序遍历序列为空，则返回null
        if (preStart > preEnd) {
            return null;
        }
        // 根据前序遍历序列确定根节点的值
        int rootVal = preorder[preStart];
        TreeNode root = new TreeNode(rootVal);
        // 在中序遍历序列中找到根节点的位置
        int rootIndex = inStart;
        while (inorder[rootIndex] != rootVal) {
            rootIndex++;
        }
        // 根据根节点在中序遍历序列中的位置，将中序遍历序列分成左子树和右子树两部分
        int leftSize = rootIndex - inStart;
        // 递归构造左子树
        root.left = buildTreeHelper(preorder, preStart + 1, preStart + leftSize, inorder, inStart, rootIndex - 1);
        // 递归构造右子树
        root.right = buildTreeHelper(preorder, preStart + leftSize + 1, preEnd, inorder, rootIndex + 1, inEnd);
        return root;
    }
}
```

**通过测试：**

`执行用时分布`：`3ms`			`击败37.92%使用 Java 的用户`

`消耗内存分布`：`43.32MB`	`击败35.02%使用 Java 的用户`



##### 第二种思路：迭代

**思路**

迭代法是一种非常巧妙的实现方法。

对于前序遍历中的任意两个连续节点 $u$ 和 $v$，根据前序遍历的流程，我们可以知道 $u$ 和 $v$ 只有两种可能的关系：

$v$ 是 $u$ 的左儿子。这是因为在遍历到 $u$ 之后，下一个遍历的节点就是 $u$ 的左儿子，即 $v$；

$u$ 没有左儿子，并且 $v$ 是 $u$ 的某个祖先节点（或者 $u$ 本身）的右儿子。如果 $u$ 没有左儿子，那么下一个遍历的节点就是 $u$ 的右儿子。如果 $u$ 没有右儿子，我们就会向上回溯，直到遇到第一个有右儿子（且 $u$ 不在它的右儿子的子树中）的节点 $u_{a}$ ，那么 $v$ 就是 $u_{a}$ 的右儿子。

第二种关系看上去有些复杂。我们举一个例子来说明其正确性，并在例子中给出我们的迭代算法。

**例子**

我们以树

```
        3
       / \
      9  20
     /  /  \
    8  15   7
   / \
  5  10
 /
4
```

为例，它的前序遍历和中序遍历分别为

```
preorder = [3, 9, 8, 5, 4, 10, 20, 15, 7]
inorder = [4, 5, 8, 10, 9, 3, 15, 20, 7]
```

我们用一个栈 `stack` 来维护「当前节点的所有还没有考虑过右儿子的祖先节点」，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，我们用一个指针 `index` 指向中序遍历的某个位置，初始值为 `0`。`index` 对应的节点是「当前节点不断往左走达到的最终节点」，这也是符合中序遍历的，它的作用在下面的过程中会有所体现。

首先我们将根节点 `3` 入栈，再初始化 `index` 所指向的节点为 `4`，随后对于前序遍历中的每个节点，我们依次判断它是栈顶节点的左儿子，还是栈中某个节点的右儿子。

* 我们遍历 `9`。`9` 一定是栈顶节点 `3` 的左儿子。我们使用反证法，假设 `9` 是 `3` 的右儿子，那么 `3` 没有左儿子，`index` 应该恰好指向 `3`，但实际上为 `4`，因此产生了矛盾。所以我们将 `9` 作为 `3` 的左儿子，并将 `9` 入栈。

  * `stack = [3, 9]`
  * `index -> inorder[0] = 4`
* 我们遍历 `8`，`5` 和 `4`。同理可得它们都是上一个节点（栈顶节点）的左儿子，所以它们会依次入栈。

  * `stack = [3, 9, 8, 5, 4]`
  * `index -> inorder[0] = 4`
* 我们遍历 `10`，这时情况就不一样了。我们发现 `index` 恰好指向当前的栈顶节点 `4`，也就是说 `4` 没有左儿子，那么 `10` 必须为栈中某个节点的右儿子。那么如何找到这个节点呢？栈中的节点的顺序和它们在前序遍历中出现的顺序是一致的，而且每一个节点的右儿子都还没有被遍历过，**那么这些节点的顺序和它们在中序遍历中出现的顺序一定是相反的**。

  > 这是因为栈中的任意两个相邻的节点，前者都是后者的某个祖先。并且我们知道，栈中的任意一个节点的右儿子还没有被遍历过，说明后者一定是前者左儿子的子树中的节点，那么后者就先于前者出现在中序遍历中。

  因此我们可以把 `index` 不断向右移动，并与栈顶节点进行比较。如果 `index` 对应的元素恰好等于栈顶节点，那么说明我们在中序遍历中找到了栈顶节点，所以将 `index` 增加 `1` 并弹出栈顶节点，直到 `index` 对应的元素不等于栈顶节点。按照这样的过程，我们弹出的最后一个节点 `x` 就是 `10` 的双亲节点，**这是因为 `10` 出现在了 `x` 与 `x` 在栈中的下一个节点的中序遍历之间** ，因此 `10` 就是 `x` 的右儿子。

  回到我们的例子，我们会依次从栈顶弹出 `4`，`5` 和 `8`，并且将 `index` 向右移动了三次。我们将 `10` 作为最后弹出的节点 `8` 的右儿子，并将 `10` 入栈。
  * `stack = [3, 9, 10]`
  * `index -> inorder[3] = 10`
* 我们遍历 `20`。同理，`index` 恰好指向当前栈顶节点 `10`，那么我们会依次从栈顶弹出 `10`，`9` 和 `3`，并且将 `index` 向右移动了三次。我们将 `20` 作为最后弹出的节点 `3` 的右儿子，并将 `20` 入栈。

  * `stack = [20]`
  * `index -> inorder[6] = 15`
* 我们遍历 `15`，将 `15` 作为栈顶节点 `20` 的左儿子，并将 `15` 入栈。

  * `stack = [20, 15]`
  * `index -> inorder[6] = 15`
* 我们遍历 `7`。`index` 恰好指向当前栈顶节点 `15`，那么我们会依次从栈顶弹出 `15` 和 `20`，并且将 `index` 向右移动了两次。我们将 `7` 作为最后弹出的节点 `20` 的右儿子，并将 `7` 入栈。

  * `stack = [7]`
  * `index -> inorder[8] = 7`

此时遍历结束，我们就构造出了正确的二叉树。

**算法**

我们归纳出上述例子中的算法流程：

我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；

我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果 `index` 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 `index`，并将当前节点作为最后一个弹出的节点的右儿子；如果 `index` 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；

无论是哪一种情况，我们最后都将当前的节点入栈。

代码：

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        // 若前序遍历序列为空，则返回null
        if (preorder == null || preorder.length == 0) {
            return null;
        }
        
        // 创建根节点，值为前序遍历序列的第一个元素
        TreeNode root = new TreeNode(preorder[0]);
        // 创建栈，用于辅助构建二叉树
        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        // 将根节点入栈
        stack.push(root);
        // 初始化中序遍历序列的索引
        int inorderIndex = 0;
        
        // 遍历前序遍历序列
        for (int i = 1; i < preorder.length; i++) {
            // 获取当前前序遍历序列中的元素值
            int preorderVal = preorder[i];
            // 获取栈顶节点
            TreeNode node = stack.peek();
            
            // 如果栈顶节点的值不等于当前中序遍历序列中的元素值，则当前元素为栈顶节点的左子节点
            if (node.val != inorder[inorderIndex]) {
                // 创建当前元素为左子节点，并入栈
                node.left = new TreeNode(preorderVal);
                stack.push(node.left);
            } else {
                // 如果栈顶节点的值等于当前中序遍历序列中的元素值，则当前元素为栈中某个节点的右子节点
                while (!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]) {
                    // 弹出所有值等于当前中序遍历序列中的元素值的节点，直到栈顶节点的值不等于当前中序遍历序列中的元素值为止
                    node = stack.pop();
                    inorderIndex++;
                }
                // 将当前元素创建为父节点的右子节点，并入栈
                node.right = new TreeNode(preorderVal);
                stack.push(node.right);
            }
        }
        
        // 返回根节点
        return root;
    }
}
```

